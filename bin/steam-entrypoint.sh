#!/usr/bin/env bash

set -e

[[ -z "${DEBUG}" ]] || [[ "${DEBUG,,}" = "false" ]] || [[ "${DEBUG,,}" = "0" ]] || set -x

if [[ "$(whoami)" != "${STEAM_USER}" ]]; then
  echo "run this script as steam-user"
  exit 1
fi

function may_update() {
  if [[ "${UPDATE_ON_START}" != "true" ]]; then
    return
  fi

  echo "\$UPDATE_ON_START is 'true'..."

  # auto checks if a update is needed, if yes, then update the server or mods
  # (otherwise it just does nothing)
  ${ARKMANAGER} update @main --verbose --update-mods --backup --no-autostart "${BETA_ARGS[@]}"
}

function create_missing_dir() {
  for DIRECTORY in "${@}"; do
    [[ -n "${DIRECTORY}" ]] || return
    if [[ ! -d "${DIRECTORY}" ]]; then
      mkdir -p "${DIRECTORY}"
      echo "...successfully created ${DIRECTORY}"
    fi
  done
}

function copy_missing_file() {
  SOURCE="${1}"
  DESTINATION="${2}"

  if [[ ! -f "${DESTINATION}" ]]; then
    cp -a "${SOURCE}" "${DESTINATION}"
    echo "...successfully copied ${SOURCE} to ${DESTINATION}"
  fi
}

function needs_install() {
  local SERVER_DIR="${ARK_SERVER_VOLUME}/server"
  if [ ! -d "${SERVER_DIR}" ]; then
    echo "${SERVER_DIR} not found ..."
    return 0
  fi

  # Backwards compatibility
  local VERSION_FILE="${SERVER_DIR}/version.txt"
  if [ -f "${VERSION_FILE}" ]; then
    echo "Already installed. (found ${VERSION_FILE})"
    return 1
  fi

  local INSTALLED_FILES=(
    "${SERVER_DIR}/steamapps/appmanifest_376030.acf"
    "${SERVER_DIR}/ShooterGame/Binaries/Linux/ShooterGameServer"
  )
  for FILE in "${INSTALLED_FILES[@]}"; do
    if [ ! -s "${FILE}" ]; then
      echo "${FILE} is not complete ..."
      return 0
    fi
  done

  echo "Already installed."
  return 1
}

function add_cluster_to_arkmanager_cfg() {
  local -r config="${ARK_TOOLS_DIR}/arkmanager.cfg"
  if ! grep -q '^arkopt_ClusterDirOverride=' "${config}"; then
    echo "Add cluster settings to old arkmanager.cfg ..."
    cat <<EOF >> "${config}"

# Cluster settings
arkflag_NoTransferFromFiltering=true
arkopt_ClusterDirOverride="/cluster"
arkopt_clusterid="\${CLUSTER_ID:-MyCluster}"
EOF
  fi
}

function add_logging_to_arkmanager_cfg() {
  local -r config="${ARK_TOOLS_DIR}/arkmanager.cfg"
  if ! grep -q '^discordWebhookURL=' "${config}"; then
    echo "Add Discord webhook settings to arkmanager.cfg ..."
    cat <<EOF >> "${config}"

# Discord webhook settings
discordWebhookURL=\${DISCORD_WEBHOOK_URL}
EOF
  fi
  if ! grep -q '^arkflag_servergamelog=' "${config}"; then
    echo "Add Logging settings to arkmanager.cfg ..."
    cat <<EOF >> "${config}"

# Logging settings
arkflag_servergamelog=\${ENABLE_SERVER_GAME_LOG:-false}
notifyCommand+='; [ "${msg}" = "${notifyMsgServerUp}" ] && ServerGameLogWatcher.sh "${serverpid}"'
EOF
  fi
}

function add_whitelist_to_arkmanager_cfg() {
  local -r config="${ARK_TOOLS_DIR}/arkmanager.cfg"
  if ! grep -q '^arkflag_exclusivejoin=' "${config}"; then
    echo "Add Whitelist settings to arkmanager.cfg ..."
    cat <<EOF >> "${config}"

# Whitelist settings
arkflag_exclusivejoin="\${ENABLE_WHITELIST:-false}"
EOF
  fi
}

function remake_sub_instances_cfg() {
  local key
  local -i i=1
  local -r instances_dir="${ARK_TOOLS_DIR}/instances"

  # remove old sub instance configs
  rm -f "${instances_dir}"/sub.*.cfg

  # create new sub instance configs
  for key in ${SUB_INSTANCE_KEYS//,/ }; do
    sed -r "${TEMPLATE_DIRECTORY}/arkmanager-sub.cfg.template" \
      -e "s/^# Template configuration.*$/# DO NOT EDIT THIS FILE - Auto-regenerated/i" \
      -e "s/<KEY>/${key}/g" \
      -e "s/<INDEX>/$((i))/g" \
      -e "s/<NUMBER_SUFFIX>/$((i+1))/g" \
      -e "s/<GAME_CLIENT_PORT>/$((GAME_CLIENT_PORT+i*2))/g" \
      -e "s/<SERVER_LIST_PORT>/$((SERVER_LIST_PORT+i))/g" \
      -e "s/<RCON_PORT>/$((RCON_PORT+i))/g" \
    > "${instances_dir}/sub.${key}.cfg"
    ((i++))
  done
}

function get_all_mod_ids() {
  local key mod_id var_name
  local -a collected=()

  [[ -n "${SERVER_MAP_MOD_ID}" ]] && collected+=("${SERVER_MAP_MOD_ID}")

  for mod_id in ${GAME_MOD_IDS//,/ }; do
    [[ -n "${mod_id}" ]] && collected+=("${mod_id}")
  done

  for key in ${SUB_INSTANCE_KEYS//,/ }; do
    var_name="SUB_${key}_SERVER_MAP_MOD_ID"
    [[ -n "${!var_name}" ]] && collected+=("${!var_name}")

    var_name="SUB_${key}_GAME_MOD_IDS"
    for mod_id in ${!var_name//,/ }; do
      [[ -n "${mod_id}" ]] && collected+=("${mod_id}")
    done
  done

  printf '%s\n' "${collected[@]}" | sort -u
}

function update_join_whitelist() {
  local -r steam_ids="$1"
  if [ -z "${steam_ids}" ]; then return; fi

  local -r whitelist_file="./server/ShooterGame/Binaries/Linux/PlayersJoinNoCheckList.txt" # must be relative path
  (cd /app; ln -sf "${whitelist_file}" ./whitelist.txt) # for easier access

  if [[ "${steam_ids,,}" =~ ^(no.*|false) ]]; then
    echo "Cleaning up join whitelist..."
    truncate -s 0 "${whitelist_file}"
    return
  fi

  echo "Setting up join whitelist ... ${steam_ids}"
  whitelist add "${steam_ids}" >/dev/null 2>&1 || true
}

function update_admin_whitelist() {
  local -r steam_ids="$1"
  if [ -z "${steam_ids}" ]; then return; fi

  local -r ids_file="${ARK_SERVER_VOLUME}/server/ShooterGame/Saved/AllowedCheaterSteamIDs.txt"
  create_missing_dir "$(dirname "${ids_file}")"

  if [[ "${steam_ids,,}" =~ ^(no.*|false) ]]; then
    echo "Cleaning up admin whitelist..."
    truncate -s 0 "${ids_file}"
    return
  fi

  echo "Setting up admin whitelist...${steam_ids}"
  local -a collected=()
  local id
  for id in ${steam_ids//,/ }; do
    [[ -n "${id}" ]] && collected+=("${id}")
  done

  printf '%s\n' "${collected[@]}" | sort -u > "${ids_file}"
}

monitor_gusini() {
    if [[ "${GUS_MONITOR,,}" != "true" ]]; then
        return
    fi

    local gus_dir="/app/server/ShooterGame/Saved/Config/LinuxServer"
    local gus_file="GameUserSettings.ini"
    echo "Starting GameUserSettings.ini monitor..."

    (
        # Wait for directory
        until [[ -d "$gus_dir" ]]; do sleep 5; done

        if ! command -v inotifywait >/dev/null; then
            echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;31m[ERROR]\033[0m [GUS_MONITOR] inotifywait not found."
            return
        fi

        local saw_modify=false
        local skip_next_access=false
        local backup_dir="/app/tmp"
        mkdir -p "$backup_dir" 2>/dev/null || true

        get_next_backup_path() {
            local base="${backup_dir}/${gus_file}.bak"
            local max_seq=0
            local f seq
            for f in "${base}."*; do
                [[ -e "$f" ]] || continue
                seq=${f##*.}
                if [[ "$seq" =~ ^[0-9]+$ ]] && (( 10#$seq > max_seq )); then
                    max_seq=$((10#$seq))
                fi
            done
            printf '%s.%04d' "$base" $((max_seq + 1))
        }

        get_previous_backup_path() {
            local base="${backup_dir}/${gus_file}.bak"
            local max_seq=0
            local f seq
            for f in "${base}."*; do
                [[ -e "$f" ]] || continue
                seq=${f##*.}
                if [[ "$seq" =~ ^[0-9]+$ ]] && (( 10#$seq > max_seq )); then
                    max_seq=$((10#$seq))
                fi
            done
            if (( max_seq > 0 )); then
                printf '%s.%04d' "$base" "$max_seq"
            fi
        }

        rm -f "${backup_dir}/${gus_file}.bak."* 2>/dev/null || true
        local initial_src="${gus_dir}/${gus_file}"
        if [[ -s "$initial_src" ]]; then
            local initial_backup
            initial_backup=$(get_next_backup_path)
            cp -f "$initial_src" "$initial_backup"
            #echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;36m[INFO] \033[0m [GUS_MONITOR] Initial backup saved: $initial_backup"
        #else
            #echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;33m[WARN] \033[0m [GUS_MONITOR] Initial backup skipped (empty file)."
        fi

        inotifywait -m -e access -e modify -e close_write --format '%f %e' "$gus_dir" 2>/dev/null | \
        while read -r filename events; do
            if [[ "$filename" == "$gus_file" ]]; then
                if [[ "$events" == *"ACCESS"* && "$skip_next_access" == true ]]; then
                    # Skip the next access event after a modify to avoid double-processing
                    skip_next_access=false
                    continue
                fi
                echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;36m[INFO] \033[0m [GUS_MONITOR] $events detected on $filename"
                if [[ "$events" == *"MODIFY"* ]]; then
                    saw_modify=true
                fi
                if [[ "$events" == *"CLOSE_WRITE"* && "$saw_modify" == true ]]; then
                    local src_file="${gus_dir}/${gus_file}"
                    if [[ -s "$src_file" ]]; then
                        local backup_path
                        backup_path=$(get_next_backup_path)
                        local prev_backup
                        prev_backup=$(get_previous_backup_path)
                        cp -f "$src_file" "$backup_path"
                        skip_next_access=true
                        #echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;36m[INFO] \033[0m [GUS_MONITOR] Backup saved: $backup_path"
                        if [[ -n "$prev_backup" && -f "$prev_backup" ]]; then
                            local changes
                            changes=$(diff -u "$prev_backup" "$backup_path" || true)
                            if [[ -n "$changes" ]]; then
                                echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;36m[INFO] \033[0m [GUS_MONITOR] Changes since last backup:\n$changes"
                            else
                                echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;36m[INFO] \033[0m [GUS_MONITOR] No changes since last backup."
                                rm -f "$backup_path" 2>/dev/null || true
                            fi
                        fi
                    else
                        echo -e "$(date +'%Y-%m-%d %H:%M:%S') \033[1;33m[WARN] \033[0m [GUS_MONITOR] Backup skipped (empty file)."
                    fi
                    saw_modify=false
                fi
            fi
        done
    ) &
}

args=("$@")
if [[ "${ENABLE_CROSSPLAY}" == "true" ]]; then
  args=('--arkopt,-crossplay' "${args[@]}")
fi
if [[ "${DISABLE_BATTLEYE}" == "true" ]]; then
  args=('--arkopt,-NoBattlEye' "${args[@]}")
fi
BETA_ARGS=(${BETA:+--beta=${BETA}} ${BETA_ACCESSCODE:+--betapassword=${BETA_ACCESSCODE}})

echo "_______________________________________"
echo ""
echo "# Ark Server - $(date)"
echo "# IMAGE_VERSION: '${IMAGE_VERSION}'"
echo "# RUNNING AS USER '${STEAM_USER}' - '$(id -u)'"
echo "# ARGS: ${args[*]}"
if [ -n "${BETA}" ]; then
  echo "# BETA: ${BETA}"
fi
echo "_______________________________________"

ARKMANAGER="$(command -v arkmanager)"
[[ -x "${ARKMANAGER}" ]] || (
  echo "Arkmanager is missing"
  exit 1
)

cd "${ARK_SERVER_VOLUME}"

echo "Setting up folder and file structure..."
create_missing_dir "${ARK_SERVER_VOLUME}/log" "${ARK_SERVER_VOLUME}/backup" "${ARK_SERVER_VOLUME}/staging"

# copy from template to server volume
copy_missing_file "${TEMPLATE_DIRECTORY}/arkmanager.cfg" "${ARK_TOOLS_DIR}/arkmanager.cfg"
copy_missing_file "${TEMPLATE_DIRECTORY}/arkmanager-user.cfg" "${ARK_TOOLS_DIR}/instances/main.cfg"
copy_missing_file "${TEMPLATE_DIRECTORY}/crontab" "${ARK_SERVER_VOLUME}/crontab"

add_cluster_to_arkmanager_cfg
add_whitelist_to_arkmanager_cfg
add_logging_to_arkmanager_cfg

remake_sub_instances_cfg

[[ -L "${ARK_SERVER_VOLUME}/Game.ini" ]] ||
  ln -s ./server/ShooterGame/Saved/Config/LinuxServer/Game.ini Game.ini
[[ -L "${ARK_SERVER_VOLUME}/GameUserSettings.ini" ]] ||
  ln -s ./server/ShooterGame/Saved/Config/LinuxServer/GameUserSettings.ini GameUserSettings.ini

if needs_install; then
  echo "No game files found. Installing..."

  create_missing_dir \
    "${ARK_SERVER_VOLUME}/server/ShooterGame/Saved/SavedArks" \
    "${ARK_SERVER_VOLUME}/server/ShooterGame/Content/Mods" \
    "${ARK_SERVER_VOLUME}/server/ShooterGame/Binaries/Linux"

  touch "${ARK_SERVER_VOLUME}/server/ShooterGame/Binaries/Linux/ShooterGameServer"
  chmod +x "${ARK_SERVER_VOLUME}/server/ShooterGame/Binaries/Linux/ShooterGameServer"

  if ! ${ARKMANAGER} install @main --verbose "${BETA_ARGS[@]}"; then
    echo "Installation failed"
    exit 1
  fi
fi

crontab "${ARK_SERVER_VOLUME}/crontab"

declare -a ALL_GAME_MOD_IDS=()
mapfile -t ALL_GAME_MOD_IDS < <(get_all_mod_ids)
if [[ ${#ALL_GAME_MOD_IDS[@]} -gt 0 ]]; then
  echo "Installing mods: '${ALL_GAME_MOD_IDS[*]}' ..."

  for MOD_ID in "${ALL_GAME_MOD_IDS[@]}"; do
    echo "...installing '${MOD_ID}'"

    if [[ -d "${ARK_SERVER_VOLUME}/server/ShooterGame/Content/Mods/${MOD_ID}" ]]; then
      echo "...already installed"
      continue
    fi

    ${ARKMANAGER} installmod "${MOD_ID}" --verbose
    echo "...done"
  done
fi

may_update
update_join_whitelist "${WHITE_STEAM_IDS}"
update_admin_whitelist "${ADMIN_STEAM_IDS}"

function terminate() {
  echo "Termination signal received."
  if ! ${ARKMANAGER} saveworld "@all" 2>/dev/null; then
    echo "Warning: Failed to issue saveworld command."
  fi
  # Both arkmanager stop @all and kill may time out.
  local pidfile
  local -i count=0
  for pidfile in ./server/ShooterGame/Saved/.arkmanager*.pid; do
    if [ -f "${pidfile}" ]; then
      local pid="$(cat "${pidfile}")"
      echo "Stopping arkmanager instance $(basename ${pidfile}) (${pid}) ..."
      kill -TERM "${pid}" 2>/dev/null && ((count++)) || true
    fi
  done
  echo "Sent stop signals to ${count} instance(s)."
  [ "${count}" -eq 0 ] && kill -TERM "${pids[@]}" 2>/dev/null || true
  echo "Waiting for all instances (${pids[*]}) to stop ..."
  wait "${pids[@]}"
  echo "done."
  exit 0
}

monitor_gusini

pids=()
# Removes state files left behind if the previous shutdown did not complete in time.
rm -vf ./server/ShooterGame/Saved/.*.pid ./server/ShooterGame/Saved/.autorestart
trap 'terminate' INT TERM
for config in ./arkmanager/instances/*.cfg; do
  instance="$(basename "${config%.*}")"
  echo "Run instance ${instance} ..."
  ${ARKMANAGER} run "@${instance}" --verbose "${args[@]}" &
  pids+=($!)
done
wait "${pids[@]}"
